#!/usr/bin/python3.4

import numpy as np
import sys
from PIL import Image, ImageOps, ImageDraw
import os, glob
import logging

_N_SIDES = 4

class NumSidesError(Exception):
	def __init__(self, N):
		self.N = N

	def __str__(self):
		return type(self).__name__ + ': required 4 sides, given ' + repr(self.N)


class PathNotExistsError(Exception):
	def __init__(self, path):
		self.path = path

	def __str__(self):
		return type(self).__name__ + ': required camera path not exists ' + self.path


class PathUnavailableError(Exception):
	def __init__(self, path):
		self.path = path

	def __str__(self):
		return type(self).__name__ + ': output directory not exists or permission denied: ' + self.path


class MissingImageError(Exception):
	def __init__(self, path):
		self.path = path

	def __str__(self):
		return type(self).__name__ + ': required image path not exists ' + self.path


class InconsistentSizeError(Exception):
	def __init__(self):
		pass

	def __str__(self):
		return type(self).__name__ + ': image sizes must be equal'


def get_ab(size):
	w, h = size
	a = h//4
	if 8*a < w:
		b = (w-8*a)//2
	else: # at least give 2a at the top
		a = w//8
		b = a
	return a, b

def prepare_side_img(img, a, b):
	(w, h) = img.size

	p1 = [(0, h), (3*a, h), (0, h-3*a)] # first triangle
	p2 = [(w, h), (w-3*a, h), (w, h-3*a)] # second one

	mask = Image.new('L', (w, h), 255) # generate mask
	ImageDraw.Draw(mask).polygon(p1, outline=1, fill=0)
	ImageDraw.Draw(mask).polygon(p2, outline=1, fill=0)

	output = ImageOps.fit(img, mask.size) # crop image
	output.putalpha(mask) # put alpha to cropped part
	return ImageOps.flip(output)

def merge_sides(sides):
	w, h = sides[0].size # side size
	a, b = get_ab((w, h))

	nh = nw = 2*h + 2*b # nh,nw=2h+2b
	logging.debug("Resolution (WxH) = (%dx%d)", nw, nh)

	a3 = 3*a
	offsets = [(h-a3, nh-h), (0, h-a3), (h-a3, 0), (nh-h, h-a3)]

	res = Image.new('RGBA', (nw, nh), (0, 0, 0, 255))
	logging.debug('Result size: (%d, %d)', res.size[0], res.size[1])

	for i in range(_N_SIDES): # paste all sides
		res.paste(sides[i], offsets[i], sides[i])

	return res

def generate_holo_img(paths):
	if len(paths) != _N_SIDES: # check there are required images
		raise NumSidesError(len(paths))

	logging.debug('Img paths: %s', repr(paths))

	imgs = []
	for p in paths: # if they dont exists this will flip
		im = Image.open(p)
		imgs.append(im)

	size = imgs[0].size # since all must to be equal sized

	for i in range(1, _N_SIDES): # check all are equal sized or flip
		if size != imgs[i].size:
			raise InconsistentSizeError()

	a, b = get_ab(size) # get a b values

	cropped = []
	rots = [0, Image.ROTATE_270, Image.ROTATE_180, Image.ROTATE_90]
	for i in range(_N_SIDES):
		tmp = prepare_side_img(imgs[i], a, b)
		if i>0:
			tmp = tmp.transpose(rots[i]) # Image.ROTATE_90 = 2, 180 = 3 ...
		cropped.append(tmp)

	return merge_sides(cropped)

def generate_holo(root_dir):
	root_dir = os.path.abspath(root_dir)
	logging.info('Root dir: %s', root_dir)
	frm_cnt = 0
	# camera paths are predetermined as c1, c2, c3, c4 and all must exists
	for ci in range(1, _N_SIDES+1): # check all camera image paths exists
		cpath = os.path.join(root_dir, 'c'+str(ci))
		if not os.path.exists(cpath):
			raise PathNotExistsError(cpath)
	# generate output folder
	out_dir = os.path.join(root_dir, 'holo')
	if not os.path.exists(out_dir):
		os.mkdir(out_dir)
	elif not os.path.isdir(out_dir) or not os.access(out_dir, os.W_OK):
		raise PathUnavailableError(out_dir)

	# get sorted image list by traverse because format might change for blender
	cpath = os.path.join(root_dir, 'c1')
	os.chdir(cpath)
	img_list = sorted(glob.glob('*.png'))

	# scan all images in all camera folders, merge them, and save them to outdir
	for iname in img_list:
		img_paths = []
		for i in range(1, _N_SIDES+1):
			ipath = root_dir + '/c' + str(i) + '/' + iname
			if not os.path.exists(ipath):
				raise MissingImageError(ipath)
			img_paths.append(ipath)
		hol_img = generate_holo_img(img_paths)
		out_path = os.path.join(out_dir, iname)
		hol_img.save(out_path)
		logging.info('Saved holo, path: %s %s', iname, out_path)

try:
	# setup logging
	logging.basicConfig(stream=sys.stdout, level=logging.INFO)
	# generate holo frames
	generate_holo(sys.argv[1])
except Exception as e:
	print(e)


"""
If cameras are in clockwise from the top
Image order for parameters (paths of side images):
\ 2 / .
 \ /  .
1 * 3 .
 / \  .
/ 0 \ .

But this will be auto generated by blender plugin

"""
